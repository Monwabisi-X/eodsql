package net.lemnik.eodsql;

import java.lang.annotation.Annotation;

import java.lang.reflect.Type;
import java.lang.reflect.Proxy;
import java.lang.reflect.ParameterizedType;

import java.sql.Connection;
import java.sql.SQLException;

import java.text.ParseException;

import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import java.util.IdentityHashMap;

import javax.sql.DataSource;

import net.lemnik.eodsql.spi.QueryFactory;
import net.lemnik.eodsql.spi.MethodImplementationFactory;

import net.lemnik.eodsql.spi.util.DataObjectBinding;
import net.lemnik.eodsql.spi.util.MapDataObjectBinding;

/**
 * <p>
 *    The <code>QueryTool</code> is used to construct an implementation of a
 *    {@link BaseQuery} interface. There are two types of {@link BaseQuery}
 *    that can be constructed with this class:
 *    <ol>
 *        <li>
 *            A simple <code>BaseQuery</code> that locks a <code>Connection</code>
 *            to the database (obtained via
 *            {@link #getQuery(Connection, Class)}). This type of
 *            query will only allow one connected {@link DataSet} at a time,
 *            the {@link DataSet#disconnect} method, or the
 *            {@link Select#disconnected} flag may be used to get around this
 *            limitation. Once a <code>DataSet</code> becomes disconnected, the
 *            queries {@link Select} methods can be used again. Attempting to
 *            call a method when the <code>Connection</code> is in use will result
 *            in an {@link java.lang.IllegalStateException}.
 *        </li><li>
 *            A pool-friendly <code>BaseQuery</code>. These can be obtained
 *            through the {@link #getQuery(DataSource, Class)}
 *            methods. The reason these queries are pool-friendly is that they
 *            do not request a <code>Connection</code> from the
 *            <code>DataSource</code> until a method is called, and they release
 *            the connections one they are done with it. This also makes them
 *            suitable for long-term storage as class-fields instead of local
 *            variables.
 *        </li>
 *    </ol>
 *    The <code>QueryTool</code> also has a notion of a "default"
 *    <code>DataSource</code>, which can be set via the
 *    {@link #setDefaultDataSource} method.
 * </p><p>
 *    The classes generated by this class are loaded via the
 *    {@link java.lang.reflect.Proxy} class.
 *    The <code>ClassLoader</code> used for the implementation
 *    classes is the <code>ContextClassLoader</code>.
 * </p><p>
 *    The query classes are validated before any initialization of Proxy's is
 *    done, if the query class violates any of the rule's for creating
 *    a <code>BaseQuery</code> the creation method will throw an
 *    {@link InvalidQueryException}
 * </p>
 * 
 * @author Jason Morris
 *
 * @see BaseQuery
 * @see TransactionQuery
 * @see Proxy
 * @see Thread#getContextClassLoader
 */
public class QueryTool {

    private static DataSource defaultDataSource = null;

    private static final Map<Class, TypeMapper> typeMap =
            new HashMap<Class, TypeMapper>();

    /**
     * <p>
     * This must be one of the ugliest generics in history. The Map
     * binds Annotation types to the MethodImplementationFactory that
     * that creates MethodImplementations for that type of annotation.
     * </p><p>
     * Currently this {@code Map} is synchronized for thread-safety. The
     * fact is that it is only used during the construction of
     * {@code BaseQuery} objects, which generally doesn't happen very
     * often (thus a ConcurrentHashMap is probably overkill).
     * </p>
     */
    private static final Map<Class<? extends Annotation>, MethodImplementationFactory<?>> methodFactories =
            Collections.synchronizedMap(
            new IdentityHashMap<Class<? extends Annotation>, MethodImplementationFactory<?>>());

    private static final QueryFactoryChain factoryChain =
            new QueryFactoryChain();

    private QueryTool() {
    }

    @SuppressWarnings("unchecked")
    private static Class<? extends Annotation> getMethodFactoryAnnotation(
            final MethodImplementationFactory<? extends Annotation> factory) {

        final Class factoryClass = factory.getClass();
        final Type[] interfaces = factoryClass.getGenericInterfaces();

        for(final Type type : interfaces) {
            if(type instanceof ParameterizedType) {
                final ParameterizedType parameterizedType =
                        (ParameterizedType)type;

                if(parameterizedType.getRawType() == MethodImplementationFactory.class) {
                    final Type[] parameters = parameterizedType.getActualTypeArguments();

                    if(parameters.length == 0 || !(parameters[0] instanceof Class)) {
                        break;
                    }

                    return (Class<? extends Annotation>)parameters[0];
                }
            }
        }

        return null;
    }

    /**
     * Sets the "default" <code>DataSource</code> for the VM. This method must be
     * invoked before {@link #getQuery(Class)} can be called, the
     * other <code>getQuery</code> methods are unaffected by the
     * default <code>DataSource</code>. This method may <b>not</b> be called with
     * <code>null</code>, and will throw an {@link java.lang.IllegalArgumentException}
     * if the specified <code>DataSource</code> is <code>null</code>.
     * @param ds the default <code>DataSource</code> for the VM
     */
    public static void setDefaultDataSource(final DataSource ds) {
        if(ds == null) {
            throw new IllegalArgumentException("the default data source " +
                    "may not be set to null.");
        }

        defaultDataSource = ds;
    }

    /**
     * Returns the "default" <code>DataSource</code> if one has been set.
     * If <code>setDefaultDataSource</code> has not been called with a
     * valid <code>DataSource</code> this method will return <code>null</code>.
     *
     *@see #setDefaultDataSource
     *@return the default <code>DataSource</code> for this VM
     */
    public static DataSource getDefaultDataSource() {
        return defaultDataSource;
    }

    /**
     * <p>
     *    Returns an instance of a generated implementation for a specific
     *    {@link BaseQuery} class. After validating that the specified class
     *    is a valid query class, this method will return a new implementation
     *    of the requested <code>BaseQuery</code> with a reference to the specified
     *    <code>DataSource</code>. Each query will keep track of any
     *    <code>Connection</code>s it opens, and force them closed when it's
     *    {@link BaseQuery#close} is called.
     * </p><p>
     *    If the default <code>DataSource</code> has not yet been set, this method
     *    will throw an {@link java.lang.IllegalStateException IllegalStateException}.
     *    If the <code>query</code> class violates any of the rule's for a
     *    query, this method will result in an
     *    {@link java.lang.IllegalArgumentException IllegalArgumentException}.
     * </p>
     * @param <T> the implementation type to return
     * @param query the <code>BaseQuery</code> to create an implementation of
     * @return an implementation of the specified <code>BaseQuery</code>
     * @throws InvalidDataTypeException if any data-type returned from a method in the
     *  query class cannot be mapped
     * @throws InvalidQueryException if any method in the query class is not valid
     */
    public static <T extends BaseQuery> T getQuery(
            final Class<T> query)
            throws InvalidDataTypeException,
            InvalidQueryException {

        if(defaultDataSource != null) {
            return getQuery(defaultDataSource, query);
        } else {
            throw new IllegalStateException("the default DataSource has " +
                    "not been set.");
        }
    }

    /**
     * Creates a new instance of a <code>BaseQuery</code> class with a reference
     * to the specified <code>DataSource</code>. Each query will keep track of any
     * <code>Connection</code>s it opens, and force them closed when it's
     * {@link BaseQuery#close} is called. If the <code>DataSource</code> is
     * <code>null</code> this method will throw an
     * <code>IllegalArgumentException</code>.
     * @param <T> the implementation type to return
     * @param dataSource the dataSource to obtain <code>Connection</code>s from
     * @param query the <code>BaseQuery</code> to create an implementation of
     * @return an implementation of the specified <code>BaseQuery</code>
     * @throws InvalidDataTypeException if any data-type returned from a method in the
     *  query class cannot be mapped
     * @throws InvalidQueryException if any method in the query class is not valid
     * @see #getQuery(Class)
     */
    public static <T extends BaseQuery> T getQuery(
            final DataSource dataSource,
            final Class<T> query)
            throws InvalidDataTypeException,
            InvalidQueryException {

        if(dataSource != null) {
            return getQuery(dataSource, query, Thread.currentThread().
                    getContextClassLoader());
        } else {
            throw new IllegalArgumentException("dataSource cannot be null");
        }
    }

    /**
     * Creates a new instance of a <code>BaseQuery</code> class with a reference
     * to the specified <code>DataSource</code>. Each query will keep track of any
     * <code>Connection</code>s it opens, and force them closed when it's
     * {@link BaseQuery#close} is called. If the <code>DataSource</code> is
     * <code>null</code> this method will throw an
     * <code>IllegalArgumentException</code>.
     * @param <T> the implementation type to return
     * @param dataSource the dataSource to obtain <code>Connection</code>s from
     * @param query the <code>BaseQuery</code> to create an implementation of
     * @param cloader the <code>ClassLoader</code> that must load the new query class
     * @return an implementation of the specified <code>BaseQuery</code>
     * @throws InvalidDataTypeException if any data-type returned from a method in the
     *  query class cannot be mapped
     * @throws InvalidQueryException if any method in the query class is not valid
     * @see #getQuery(Class)
     */
    public static <T extends BaseQuery> T getQuery(
            final DataSource dataSource,
            final Class<T> query,
            final ClassLoader cloader)
            throws InvalidDataTypeException,
            InvalidQueryException {

        if(dataSource != null) {
            return factoryChain.create(dataSource, query, cloader);
        } else {
            throw new IllegalArgumentException("dataSource cannot be null");
        }
    }

    /**
     * Creates a new instance of a <code>BaseQuery</code> class with a specific
     * {@link java.sql.Connection}. If the <code>Connection</code> is
     * <code>null</code> this method will throw an
     * <code>IllegalArgumentException</code>. The specified <code>Connection</code>
     * will be closed when the {@link BaseQuery#close} method is called.
     * @param <T> the implementation type to return
     * @see #getQuery(Class)
     * @param connection the connection to use for the query class
     * @param query the <code>BaseQuery</code> to create an implementation of
     * @return an implementation of the specified <code>BaseQuery</code>
     * @throws InvalidDataTypeException if any data-type returned from a method in the
     *  query class cannot be mapped
     * @throws InvalidQueryException if any method in the query class is not valid
     */
    public static <T extends BaseQuery> T getQuery(
            final Connection connection,
            final Class<T> query)
            throws InvalidDataTypeException,
            InvalidQueryException {

        return getQuery(connection, query, Thread.currentThread().
                getContextClassLoader());
    }

    /**
     * Creates a new instance of a <code>BaseQuery</code> class with a specific
     * {@link java.sql.Connection}. If the <code>Connection</code> is
     * <code>null</code> this method will throw an
     * <code>IllegalArgumentException</code>. The specified <code>Connection</code>
     * will be closed when the {@link BaseQuery#close} method is called.
     * @param <T> the implementation type to return
     * @see #getQuery(Class)
     * @param connection the connection to use for the query class
     * @param query the <code>BaseQuery</code> to create an implementation of
     * @param loader the <code>ClassLoader</code> that must load the new query class
     * @return an implementation of the specified <code>BaseQuery</code>
     * @throws InvalidDataTypeException if any data-type returned from a method in the
     *  query class cannot be mapped
     * @throws InvalidQueryException if any method in the query class is not valid
     */
    public static <T extends BaseQuery> T getQuery(
            final Connection connection,
            final Class<T> query,
            final ClassLoader loader)
            throws InvalidDataTypeException,
            InvalidQueryException {

        return factoryChain.create(connection, query, loader);
    }

    /**
     *<p>
     * Sometimes you need to perform a less structured "SELECT" than a Query interface allows. Although this method
     * is significantly slower than building a Query interface, it provides needed functionality that a Query
     * interface cannot. The returned {@link DataSet} will be connected to the database and will be updateable, 
     * and the Connection will be taken from the {@link #setDefaultDataSource(DataSource) defaultDataSource}.
     *</p><p>
     * This method does no caching of any sort, and the query will be re-parsed each time it is executed. It however
     * provides the same primitive-type abstraction that a Query interface provides you with. The query string is
     * parsed in the same way as a query string passed to an {@link Select @Select} annotation.
     *</p><p>
     * This method is the same as calling <code>select(getDefaultDataSource(), type, query, parameters)</code>.
     *</p>
     *
     * @param <T> the type to bind each row to
     * @param type the data-type you want returned in the {@link DataSet}
     * @param query the SQL query to be executed
     * @param parameters the parameters to be used in conjunction with the query string.
     * @return a connected {@code DataSet} containing the selected rows
     *      reflected as the row data-type requested
     * @see #select(DataSource, Class, String, Object...)
     * @throws InvalidDataTypeException if the given {@code type} cannot
     *      be bound as a row data-type
     * @throws InvalidQueryException if the query string given cannot
     *      be parsed, or doesn't match the given parameters
     * @throws IllegalStateException is the defaultDataSource has not yet been set
     */
    public static <T> DataSet<T> select(
            final Class<T> type,
            final String query,
            final Object... parameters)
            throws InvalidDataTypeException,
            InvalidQueryException {

        if(defaultDataSource != null) {
            return select(defaultDataSource, type, query, parameters);
        } else {
            throw new IllegalStateException(
                    "the default DataSource has not been set.");
        }
    }

    /**
     *<p>
     * Sometimes you need to perform a less structured "SELECT" than a Query interface allows. Although this method
     * is significantly slower than building a Query interface, it provides needed functionality that a Query
     * interface cannot. The returned {@link DataSet} will be connected to the database and will be updateable 
     * and the Connection is obtained from the <code>DataSource</code> provided.
     *</p><p>
     * This method does no caching of any sort, and the query will be re-parsed each time it is executed. It however
     * provides the same primitive-type abstraction that a Query interface provides you with. The query string is
     * parsed in the same way as a query string passed to an {@link Select @Select} annotation.
     *</p>
     *
     * @param <T> the type to bind each row to
     * @param dataSource the <code>DataSource</code> to obtain a database connection through
     * @param type the data-type you want returned in the {@link DataSet}
     * @param query the SQL query to be executed
     * @return  a connected {@code DataSet} containing the selected rows
     *      reflected as the row data-type requested
     * @param parameters the parameters to be used in conjunction
     *      with the query string.
     * @throws InvalidDataTypeException if the given {@code type} cannot
     *      be bound as a row data-type
     * @throws InvalidQueryException if the query string given cannot
     *      be parsed, or doesn't match the given parameters
     * @throws IllegalArgumentException is the <code>DataSource</code>
     *      provided is <code>null</code>
     */
    public static <T> DataSet<T> select(
            final DataSource dataSource,
            final Class<T> type,
            final String query,
            final Object... parameters)
            throws InvalidDataTypeException,
            InvalidQueryException {

        if(dataSource == null) {
            throw new IllegalArgumentException(
                    "A DataSource must be specified for QueryTool.select");
        }

        if(type == null) {
            throw new IllegalArgumentException(
                    "The DataObject type must be non-null for QueryTool.select");
        }

        if(query == null || query.length() == 0) {
            throw new IllegalArgumentException(
                    "You must specify a query for QueryTool.select");
        }

        DataObjectBinding.validate(type);

        try {
            return QuickQueryUtil.selectDataSet(
                    dataSource.getConnection(),
                    true,
                    type,
                    query,
                    parameters);
        } catch(final SQLException sqle) {
            throw new InvalidQueryException(
                    "Couldn't execute query: '" + query + "'", sqle);
        } catch(final ParseException pe) {
            throw new InvalidQueryException(
                    "Cannot parser EoD SQL query: '" + query + "'", pe);
        }
    }

    /**
     *<p>
     * Sometimes you need to perform a less structured "SELECT" than a Query interface allows. Although this method
     * is significantly slower than building a Query interface, it provides needed functionality that a Query
     * interface cannot. The returned {@link DataSet} will be connected to the database and will be updateable.
     *</p><p>
     * This method does no caching of any sort, and the query will be re-parsed each time it is executed. It however
     * provides the same primitive-type abstraction that a Query interface provides you with. The query string is
     * parsed in the same way as a query string passed to an {@link Select @Select} annotation.
     *</p>
     *
     * @param <T> the type to bind each row to
     * @param connection the <code>Connection</code> to use to perform the query, closing the
     *      {@code DataSet} will <b>not</b> close this {@code Connection}
     * @param type the data-type you want returned in the {@link DataSet}
     * @param query the SQL query to be executed
     * @param parameters the parameters to be used in
     *      conjunction with the query string.
     * @return  a connected {@code DataSet} containing the selected rows
     *      reflected as the row data-type requested
     * @throws InvalidDataTypeException if the given {@code type} cannot
     *      be bound as a row data-type
     * @throws InvalidQueryException if the query string given cannot
     *      be parsed, or doesn't match the given parameters
     * @throws IllegalArgumentException is the <code>DataSource</code>
     *      provided is <code>null</code>
     */
    public static <T> DataSet<T> select(
            final Connection connection,
            final Class<T> type,
            final String query,
            final Object... parameters)
            throws InvalidDataTypeException,
            InvalidQueryException {

        if(connection == null) {
            throw new IllegalArgumentException(
                    "A Connection must be specified for QueryTool.select");
        }

        if(type == null) {
            throw new IllegalArgumentException(
                    "The DataObject type must be non-null for QueryTool.select");
        }

        if(query == null || query.length() == 0) {
            throw new IllegalArgumentException(
                    "You must specify a query for QueryTool.select");
        }

        DataObjectBinding.validate(type);

        try {
            return QuickQueryUtil.selectDataSet(
                    connection,
                    false,
                    type,
                    query,
                    parameters);
        } catch(SQLException sqle) {
            throw new InvalidQueryException(
                    "Couldn't execute query: '" + query + "'", sqle);
        } catch(ParseException pe) {
            throw new InvalidQueryException(
                    "Cannot parser EoD SQL query: '" + query + "'", pe);
        }
    }

    /**
     *<p>
     * Sometimes you need to perform a less structured "SELECT" than a Query interface allows. Although this method
     * is significantly slower than building a Query interface, it provides needed functionality that a Query
     * interface cannot. The returned {@link DataSet} will be connected to the database
     * and the Connection will be taken from the {@link #setDefaultDataSource(DataSource) defaultDataSource}.
     *</p><p>
     * This method does no caching of any sort, and the query will be re-parsed each time it is executed. It however
     * provides the same primitive-type abstraction that a Query interface provides you with. The query string is
     * parsed in the same way as a query string passed to an {@link Select @Select} annotation.
     *</p><p>
     * This method is the same as calling <code>select(getDefaultDataSource(), type, query, parameters)</code>.
     *</p>
     *
     * @param query the SQL query to be executed
     * @param parameters the parameters to be used in conjunction with the query string.
     * @return  a connected {@code DataSet} containing the selected rows
     *      reflected as a map where each key is one column name 
     * @see #select(DataSource, Class, String, Object...)
     * @throws InvalidQueryException if the query string given cannot
     *      be parsed, or doesn't match the given parameters
     * @throws IllegalStateException is the defaultDataSource has not yet been set
     */
    public static DataSet<Map<String, Object>> select(
            final String query,
            final Object... parameters)
            throws InvalidDataTypeException,
            InvalidQueryException {

        if(defaultDataSource != null) {
            return select(defaultDataSource, 
                    MapDataObjectBinding.getStringObjectMapObjectType(), 
                    query,
                    parameters);
        } else {
            throw new IllegalStateException(
                    "the default DataSource has not been set.");
        }
    }

    /**
     *<p>
     * Sometimes you need to perform a less structured "SELECT" than a Query interface allows. Although this method
     * is significantly slower than building a Query interface, it provides needed functionality that a Query
     * interface cannot. The returned {@link DataSet} will be connected to the database 
     * and the Connection is obtained from the <code>DataSource</code> provided.
     *</p><p>
     * This method does no caching of any sort, and the query will be re-parsed each time it is executed. It however
     * provides the same primitive-type abstraction that a Query interface provides you with. The query string is
     * parsed in the same way as a query string passed to an {@link Select @Select} annotation.
     *</p>
     *
     * @param dataSource the <code>DataSource</code> to obtain a database connection through
     * @param query the SQL query to be executed
     * @param parameters the parameters to be used in conjunction
     *      with the query string.
     * @return  a connected {@code DataSet} containing the selected rows
     *      reflected as a map where each key is one column name 
     * @throws InvalidQueryException if the query string given cannot
     *      be parsed, or doesn't match the given parameters
     * @throws IllegalArgumentException is the <code>DataSource</code>
     *      provided is <code>null</code>
     */
    public static DataSet<Map<String, Object>> select(
            final DataSource dataSource,
            final String query,
            final Object... parameters)
            throws InvalidDataTypeException,
            InvalidQueryException {

        return select(dataSource, 
                MapDataObjectBinding.getStringObjectMapObjectType(), 
                query,
                parameters);
    }

    /**
     *<p>
     * Sometimes you need to perform a less structured "SELECT" than a Query interface allows. Although this method
     * is significantly slower than building a Query interface, it provides needed functionality that a Query
     * interface cannot. The returned {@link DataSet} will be connected to the database .
     *</p><p>
     * This method does no caching of any sort, and the query will be re-parsed each time it is executed. It however
     * provides the same primitive-type abstraction that a Query interface provides you with. The query string is
     * parsed in the same way as a query string passed to an {@link Select @Select} annotation.
     *</p>
     *
     * @param connection the <code>Connection</code> to use to perform the query, closing the
     *      {@code DataSet} will <b>not</b> close this {@code Connection}
     * @param query the SQL query to be executed
     * @param parameters the parameters to be used in
     *      conjunction with the query string.
     * @return  a connected {@code DataSet} containing the selected rows
     *      reflected as a map where each key is one column name 
     * @throws InvalidQueryException if the query string given cannot
     *      be parsed, or doesn't match the given parameters
     * @throws IllegalArgumentException is the <code>DataSource</code>
     *      provided is <code>null</code>
     */
    public static DataSet<Map<String, Object>> select(
            final Connection connection,
            final String query,
            final Object... parameters)
            throws InvalidDataTypeException,
            InvalidQueryException {

        return select(connection, 
                MapDataObjectBinding.getStringObjectMapObjectType(), 
                query,
                parameters);
    }

    /**
     *<p>
     * Sometimes you need to perform a less structured "UPDATE", "INSERT" or "DELETE" than a Query interface allows. Although this method
     * is significantly slower than building a Query interface, it provides needed functionality that a Query
     * interface cannot.
     *</p><p>
     * This method does no caching of any sort, and the query will be re-parsed each time it is executed. It however
     * provides the same primitive-type abstraction that a Query interface provides you with. The query string is
     * parsed in the same way as a query string passed to an {@link Select @Select} annotation.
     *</p>
     *
     * @param connection the <code>Connection</code> to use to perform the query
     * @param query the SQL query to be executed
     * @param parameters the parameters to be used in
     *      conjunction with the query string.
     * @return either (1) the row count for <code>INSERT</code>, <code>UPDATE</code>,
     *         or <code>DELETE</code> statements
     *         or (2) 0 for SQL statements that return nothing
     * @throws InvalidDataTypeException if the given {@code type} cannot
     *      be bound as a row data-type
     * @throws InvalidQueryException if the query string given cannot
     *      be parsed, or doesn't match the given parameters
     * @throws IllegalArgumentException is the <code>DataSource</code>
     *      provided is <code>null</code>
     */
    public static int update(
            final Connection connection,
            final String query,
            final Object... parameters)
            throws InvalidDataTypeException,
            InvalidQueryException {

        if(connection == null) {
            throw new IllegalArgumentException(
                    "A Connection must be specified for update");
        }

        if(query == null || query.length() == 0) {
            throw new IllegalArgumentException(
                    "You must specify a query for update");
        }

        try {
            return QuickQueryUtil.update(
                    connection,
                    false,
                    query,
                    parameters);
        } catch(SQLException sqle) {
            throw new InvalidQueryException(
                    "Couldn't execute query: '" + query + "'", sqle);
        } catch(ParseException pe) {
            throw new InvalidQueryException(
                    "Cannot parser EoD SQL query: '" + query + "'", pe);
        }
    }

    /**
     *<p>
     * Sometimes you need to perform a less structured "UPDATE", "INSERT" or "DELETE" than a Query interface allows. Although this method
     * is significantly slower than building a Query interface, it provides needed functionality that a Query
     * interface cannot.
     *</p><p>
     * This method does no caching of any sort, and the query will be re-parsed each time it is executed. It however
     * provides the same primitive-type abstraction that a Query interface provides you with. The query string is
     * parsed in the same way as a query string passed to an {@link Select @Select} annotation.
     *</p>
     *
     * @param dataSource the <code>DataSource</code> to use get the connection from to perform the query
     * @param query the SQL query to be executed
     * @param parameters the parameters to be used in
     *      conjunction with the query string.
     * @return either (1) the row count for <code>INSERT</code>, <code>UPDATE</code>,
     *         or <code>DELETE</code> statements
     *         or (2) 0 for SQL statements that return nothing
     * @throws InvalidDataTypeException if the given {@code type} cannot
     *      be bound as a row data-type
     * @throws InvalidQueryException if the query string given cannot
     *      be parsed, or doesn't match the given parameters
     * @throws IllegalArgumentException is the <code>DataSource</code>
     *      provided is <code>null</code>
     */
    public static int update(
            final DataSource dataSource,
            final String query,
            final Object... parameters)
            throws InvalidDataTypeException,
            InvalidQueryException {

        if(dataSource == null) {
            throw new IllegalArgumentException(
                    "A DataSource must be specified for update");
        }

        if(query == null || query.length() == 0) {
            throw new IllegalArgumentException(
                    "You must specify a query for update");
        }

        try {
            return QuickQueryUtil.update(
                    dataSource.getConnection(),
                    false,
                    query,
                    parameters);
        } catch(SQLException sqle) {
            throw new InvalidQueryException(
                    "Couldn't execute query: '" + query + "'", sqle);
        } catch(ParseException pe) {
            throw new InvalidQueryException(
                    "Cannot parser EoD SQL query: '" + query + "'", pe);
        }
    }

    /**
     *<p>
     * Sometimes you need to perform a less structured "UPDATE", "INSERT" or "DELETE" than a Query interface allows. Although this method
     * is significantly slower than building a Query interface, it provides needed functionality that a Query
     * interface cannot.
     *</p><p>
     * This method does no caching of any sort, and the query will be re-parsed each time it is executed. It however
     * provides the same primitive-type abstraction that a Query interface provides you with. The query string is
     * parsed in the same way as a query string passed to an {@link Select @Select} annotation.
     *</p><p>
     * This method is the same as calling <code>update(getDefaultDataSource(), query, parameters)</code>.
     *</p>
     *
     * @param query the SQL query to be executed
     * @param parameters the parameters to be used in
     *      conjunction with the query string.
     * @return either (1) the row count for <code>INSERT</code>, <code>UPDATE</code>,
     *         or <code>DELETE</code> statements
     *         or (2) 0 for SQL statements that return nothing
     * @throws InvalidDataTypeException if the given {@code type} cannot
     *      be bound as a row data-type
     * @throws InvalidQueryException if the query string given cannot
     *      be parsed, or doesn't match the given parameters
     * @throws IllegalArgumentException is the <code>DataSource</code>
     *      provided is <code>null</code>
     */
    public static int update(
            final String query,
            final Object... parameters)
            throws InvalidDataTypeException,
            InvalidQueryException {
        if(defaultDataSource != null) {
            return update(defaultDataSource, query, parameters);
        } else {
            throw new IllegalStateException(
                    "the default DataSource has not been set.");
        }
    }

    /**
     * <p>
     * Returns the <code>Map</code> that specifies how Java types should
     * be mapped to SQL types and back again. This <code>Map</code> may be
     * modified directly to add new types to the system. The <code>Map</code>
     * may also be used to remove types from the system.
     * </p><p>
     * The TypeMap is <b>not</b> thread-safe for writes. So make sure any writes
     * you wish to do on the TypeMap take place before any database work is done.
     * </p>
     *
     *@return the current data-type <code>Map</code>
     */
    public static Map<Class, TypeMapper> getTypeMap() {
        return typeMap;
    }

    /**
     * <p>
     * This method can be used to ensure that a specific type of {@link net.lemnik.eodsql.spi.QueryFactory}
     * is known by the <code>QueryTool</code>. If the Java version is 1.6 or higher, the <code>QueryFactory</code>
     * classes should have been discovered on startup by using the {@link java.util.ServiceLoader}.
     * </p><p>
     * This method is mostly useful if the Java version is 5 (1.5), since the {@link java.util.ServiceLoader} class
     * will not be available.
     * </p>
     * 
     * @param factory The factory to ensure is known by the <code>QueryTool</code>
     * @throws IllegalArgumentException if the <code>factory</code> specified is <code>null</code>
     * @since 2.0
     */
    public static void addQueryFactory(
            final QueryFactory factory)
            throws IllegalArgumentException {

        if(factory == null) {
            throw new IllegalArgumentException("QueryFactory may not be null!");
        }

        factoryChain.add(factory);
    }

    /**
     * The opposite of {@link #addQueryFactory}, this method deregisters a specific <code>QueryFactory</code>.
     * This method can be used on any <code>QueryFactory</code> (including those auto-discovered with the
     * {@link java.util.ServiceLoader}), and will never throw an Exception.
     * 
     * @param factory the <code>QueryFactory</code> to deregister
     * @since 2.0
     */
    public static void removeQueryFactory(
            final QueryFactory factory) {

        if(factory != null) {
            factoryChain.remove(factory);
        }
    }

    /**
     * <p>
     * Manually registers a new {@code MethodImplementationFactory} object. Under Java 6
     * there is generally no need to do this, as MethodImplementationFactories are discovered
     * with a {@code ServiceLoader}. However under Java 5 you will need to invoke this method
     * with any custom {@code MethodImplementationFactories} you have created.
     * </p><p>
     * Note: This method is for advanced use only, and is generally unneeded.
     * </p>
     * 
     * @param factory the factory to register
     * @throws java.lang.IllegalArgumentException if the factory is {@literal null} or does not
     *      have a solid (non-wildcard) {@code Annotation} type in it's generic-declaration
     */
    public static void addMethodImplementationFactory(
            final MethodImplementationFactory<? extends Annotation> factory)
            throws IllegalArgumentException {

        if(factory == null) {
            throw new IllegalArgumentException(
                    "MethodImplementationFactory may not be null");
        }


        final Class<? extends Annotation> annotation =
                getMethodFactoryAnnotation(factory);

        if(annotation != null) {
            methodFactories.put(annotation, factory);
        } else {
            throw new IllegalArgumentException(
                    "A MethodImplementationFactory must directly " +
                    "implement MethodImplementationFactory and have the " +
                    "final Annotation type in it's generic declaration.");
        }
    }

    /**
     * Try and find a {@code MethodImplementationFactory} for the specified {@code Annotation}
     * type. This method will either return the Method or {@literal null} if none could be found
     * for the given {@code Annotation} type.
     * 
     * @param <T> the {@code Annotation} type to look for
     * @param annotationType the {@code Annotation} type to look for
     * @return the {@code MethodImplementationFactory} related to the specified {@code Annotation}
     *      type, or {@literal null} if none could be found
     */
    public static <T extends Annotation> MethodImplementationFactory<T> getMethodImplementationFactory(final Class<T> annotationType) {
        @SuppressWarnings("unchecked")
        final MethodImplementationFactory<T> factory =
                (MethodImplementationFactory<T>)methodFactories.get(
                annotationType);

        return factory;
    }

}
