package net.lemnik.eodsql.spi.util;

import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.ResultSetMetaData;

import java.util.Map;
import java.util.Iterator;
import java.util.concurrent.atomic.AtomicReference;

import net.lemnik.eodsql.QueryTool;
import net.lemnik.eodsql.TypeMapper;
import net.lemnik.eodsql.ResultColumn;
import net.lemnik.eodsql.EoDException;

import net.lemnik.eodsql.InvalidDataTypeException;

import net.lemnik.eodsql.spi.util.DataObjectBindingCache.ColumnName;

/**
 * Created on 2008/06/13
 * @author Jason Morris
 */
class DefaultDataObjectBinding<T> extends DataObjectBinding<T> {

    private static final boolean HAVE_ACCESSIBLE_PERMISSION =
            DataObjectBindingCache.HAVE_ACCESSIBLE_PERMISSION;

    private TypeMapper<?>[] mappers = null;

    private MutableColumn[] columns;

    private String[] keyColumns = null;

    private enum State {

        NOT_COMPLETE, SET_BINDING_TYPE_IN_PROCESS, COMPLETION_IN_PROCESS, COMPLETE

    }
    private AtomicReference<State> complete = new AtomicReference<DefaultDataObjectBinding.State>(State.NOT_COMPLETE);

    DefaultDataObjectBinding(final Class<T> clazz) {
        setObjectType(clazz);
    }

    private void complete(
            final ResultSetMetaData metaData)
            throws EoDException {

        try {
            final DataObjectBindingCache cache =
                    DataObjectBindingCache.getDataObjectBindingCache(
                    getObjectType());

            switch(getBindingType()) {
                case FIRST_COLUMN_BINDING:
                case KEYS_BINDING:
                    init(cache.getKeyColumns(), metaData);
                    break;
                default:
                    init(cache.getNormalColumns(), metaData);
            }
        } catch(final SQLException sqlException) {
            throw new EoDException("Could not create binding for data-type: "
                    + getObjectType().getName(), sqlException);
        }
    }

    private void ensureComplete(
            final ResultSetMetaData meta)
            throws EoDException {
        
        do {
            final State state = complete.get();
            if(state == State.COMPLETE) {
                break;
            }
            if(complete.compareAndSet(State.NOT_COMPLETE, State.COMPLETION_IN_PROCESS)) {
                try {
                    complete(meta);
                    complete.set(State.COMPLETE);
                    break;
                } catch(RuntimeException ex) {
                    complete.set(State.NOT_COMPLETE);
                    throw ex;
                }
            } else {
                try {
                    Thread.sleep(1L);
                } catch(InterruptedException ex) {
                }
            }
        } while(true);
    }

    /**
     * The implementation of the {@link #getKeyColumns()} method. This
     * implementation has no direct effect on the {@link #keyColumns}
     * field, and is simply used to extract the required data from the
     * composed bindings.
     * 
     * @return the names of the columns that are marked as "keys" by the
     *      type we are binding to and from
     */
    private String[] getKeyColumns0() {
        final DataObjectBindingCache cache = DataObjectBindingCache.getDataObjectBindingCache(getObjectType());

        final Map<ColumnName, MutableColumn> columnMap = cache.getKeyColumns();

        final int length = columnMap.size();

        final String[] names = new String[length];
        final Iterator<ColumnName> columnIterator =
                columnMap.keySet().iterator();

        for(int i = 0; i < length; i++) {
            names[i] = columnIterator.next().getColumnName();
        }

        return names;
    }

    private void init(
            final Map<ColumnName, MutableColumn> map,
            final ResultSetMetaData metaData)
            throws SQLException,
            EoDException {

        final Map<Class, TypeMapper> typemap = QueryTool.getTypeMap();

        if(getBindingType() == BindingType.FIRST_COLUMN_BINDING) {
            if(map.size() != 1) {
                throw new EoDException(
                        "Exactly one AutoGeneratedKeys field required for a "
                        + "FIRST_COLUMN_BINDING.");
            }

            final MutableColumn column = map.values().iterator().next();
            final TypeMapper mapper = typemap.get(column.getType());

            if(mapper == null) {
                throw new EoDException("No TypeMapper found for property: "
                        + column + " of type " + column.getType().getName());
            }

            mappers = new TypeMapper[]{mapper};
            columns = new MutableColumn[]{column};
        } else {
            mappers = new TypeMapper[metaData.getColumnCount()];
            columns = new MutableColumn[metaData.getColumnCount()];

            for(int i = 0; i < metaData.getColumnCount(); i++) {
                final String column = metaData.getColumnLabel(i + 1);
                final MutableColumn mutable = map.get(new ColumnName(column));

                // there could be columns in the ResultSet which are /not/ in the object
                // there could also be fields in the object that are /not/ in the ResultSet
                if(mutable != null) {
                    final TypeMapper mapper = typemap.get(mutable.getType());

                    if(mapper == null) {
                        throw new EoDException(
                                "No TypeMapper found for object: "
                                + mutable + " of type "
                                + mutable.getType().getName());
                    }

                    mappers[i] = mapper;
                    columns[i] = mutable;
                } else {
                    mappers[i] = null;
                    columns[i] = null;
                }
            }
        }
    }

    @Override
    public T newInstance() throws EoDException {
        try {
            final Constructor<T> constructor = getObjectType().
                    getDeclaredConstructor();

            if(!constructor.isAccessible() && HAVE_ACCESSIBLE_PERMISSION) {
                constructor.setAccessible(true);
            }

            return constructor.newInstance();
        } catch(final IllegalArgumentException illegalArgumentException) {
            throw new EoDException("Cannot instantiate type: "
                    + getObjectType().getName()
                    + ". Make sure it has a public default constrcutor.",
                    illegalArgumentException);
        } catch(final InvocationTargetException invocationTargetException) {
            throw new EoDException("Cannot instantiate type: "
                    + getObjectType().getName()
                    + ". Make sure it has a public default constrcutor.",
                    invocationTargetException);
        } catch(final NoSuchMethodException noSuchMethodException) {
            throw new EoDException("Cannot instantiate type: "
                    + getObjectType().getName()
                    + ". Make sure it has a public default constrcutor.",
                    noSuchMethodException);
        } catch(final SecurityException securityException) {
            throw new EoDException("Cannot instantiate type: "
                    + getObjectType().getName()
                    + ". Make sure it has a public default constrcutor.",
                    securityException);
        } catch(final InstantiationException instantiationException) {
            throw new EoDException("Cannot instantiate type: "
                    + getObjectType().getName()
                    + ". Make sure it has a public default constrcutor.",
                    instantiationException);
        } catch(final IllegalAccessException accessException) {
            throw new EoDException("Cannot instantiate type: "
                    + getObjectType().getName()
                    + ". Make sure it has a public default constrcutor.",
                    accessException);
        }
    }

    @Override
    public boolean setBindingType(final BindingType bindingType) {
        if(complete.compareAndSet(State.NOT_COMPLETE, State.SET_BINDING_TYPE_IN_PROCESS)) {
            try {
                return super.setBindingType(bindingType);
            } finally {
                complete.set(State.NOT_COMPLETE);
            }
        }

        return false;
    }

    @Override
    public void unmarshall(
            final ResultSet row,
            final T into)
            throws SQLException,
            EoDException {

        ensureComplete(row.getMetaData());

        final int length = columns.length;

        for(int i = 0; i < length; i++) {
            if(columns[i] != null) {
                Object value = mappers[i].get(row, i + 1);

                if(row.wasNull()) {
                    value = null;
                }

                columns[i].set(into, value);
            }
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public void marshall(
            final T from,
            final ResultSet results)
            throws SQLException,
            EoDException {

        final ResultSetMetaData meta = results.getMetaData();

        ensureComplete(meta);

        final int length = columns.length;

        for(int i = 0; i < length; i++) {
            if(columns[i] != null) {
                final Object value = columns[i].get(from);

                if(value == null) {
                    results.updateNull(i);
                } else {
                    ((TypeMapper)mappers[i]).set(results, i + 1, value);
                }
            }
        }
    }

    @Override
    public String[] getKeyColumnNames() {
        switch(getBindingType()) {
            case KEYS_BINDING:
            case FIRST_COLUMN_BINDING:
                String[] keys = keyColumns;

                if(keys == null) {
                    keyColumns = keys = getKeyColumns0();
                }

                return keys;
            default:
                return NO_KEY_COLUMNS;
        }
    }

    public static void validate(final Class<?> dataObjectClass)
            throws InvalidDataTypeException {

        final Field[] fields = dataObjectClass.getFields();
        final Method[] methods = dataObjectClass.getMethods();

        try {
            final Constructor<?> constructor =
                    dataObjectClass.getDeclaredConstructor();

            if(!HAVE_ACCESSIBLE_PERMISSION
                    && !Modifier.isPublic(constructor.getModifiers())) {

                throw new InvalidDataTypeException("EoD SQL does not have "
                        + "permission to set the accessable flag. All "
                        + "DataObject classes must have a "
                        + "default constructor.", dataObjectClass);
            }
        } catch(final NoSuchMethodException noSuchMethodException) {
            throw new InvalidDataTypeException("All Data-Object classes "
                    + "must have a default constructor.", dataObjectClass);
        }

        for(final Field f : fields) {
            if(f.isAnnotationPresent(ResultColumn.class)) {
                validateResultColumnMember(f);
            }
        }

        for(final Method m : methods) {
            if(m.isAnnotationPresent(ResultColumn.class)) {
                validateResultColumnMember(m);
            }
        }
    }

    private static void validateResultColumnMember(final Member member) {
        final int mod = member.getModifiers();

        if(!HAVE_ACCESSIBLE_PERMISSION) {
            if(!Modifier.isPublic(mod)) {
                throw new InvalidDataTypeException(
                        "EoD SQL does not have permission "
                        + "to set the accessable flag. All members "
                        + "annotated with @ResultColumn "
                        + "must therefore be public: "
                        + member.getName(),
                        member.getDeclaringClass());
            }
        }

        if(Modifier.isStatic(mod)) {
            throw new InvalidDataTypeException(
                    "Members annotated with @ResultColumn may not "
                    + "be static: " + member.getName(),
                    member.getDeclaringClass());
        }

        if(member instanceof Field) {
            if(Modifier.isFinal(mod)) {
                throw new InvalidDataTypeException(
                        "A field annotated with @ResultColumn may "
                        + "not be final: " + member.getName(),
                        member.getDeclaringClass());
            } else if(Modifier.isTransient(mod)) {
                throw new InvalidDataTypeException(
                        "A field annotated with @ResultColumn may "
                        + "not be transient: " + member.getName(),
                        member.getDeclaringClass());
            }
        }

        if(member instanceof Method) {
            final Method method = (Method)member;

            if(method.getParameterTypes().length != 1) {
                throw new InvalidDataTypeException(
                        "A Method annotated with @ResultColumn "
                        + "must accept exactly 1 parameter.",
                        member.getDeclaringClass(),
                        method);
            }
        }
    }
}
