package net.lemnik.eodsql.spi.util;

import java.lang.ref.SoftReference;
import java.lang.ref.ReferenceQueue;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ReflectPermission;

import java.util.Map;
import java.util.HashMap;

import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ConcurrentHashMap;

import net.lemnik.eodsql.ResultColumn;
import net.lemnik.eodsql.AutoGeneratedKeys;

/**
 * Created on Jan 30, 2009
 * @author jason
 */
class DataObjectBindingCache {

    public static final boolean HAVE_ACCESSIBLE_PERMISSION =
            checkAccessablePermission();

    private static final ConcurrentMap<Class<?>, CachedBinding> cache =
            new ConcurrentHashMap<Class<?>, CachedBinding>();

    private static final ReferenceQueue<DataObjectBindingCache> referenceQueue =
            new ReferenceQueue<DataObjectBindingCache>();

    private final Map<ColumnName, MutableColumn> normalColumns =
            new HashMap<ColumnName, MutableColumn>();

    private final Map<ColumnName, MutableColumn> keyColumns =
            new HashMap<ColumnName, MutableColumn>();

    private DataObjectBindingCache(final Class<?> clazz) {
        Class<?> current = clazz;

        while(current != Object.class) {
            final boolean keyType = current.isAnnotationPresent(
                    AutoGeneratedKeys.class);

            scanFields(current, keyType);
            scanMethods(current, keyType);

            current = current.getSuperclass();
        }
    }

    private void addColumnImpl(
            final Map<ColumnName, MutableColumn> map,
            final String name,
            final MutableColumn column) {

        final ColumnName columnName = new ColumnName(name);

        // We /want/ to override the fields found with any methods annotated
        // by a ResultColumn of the same name. This allows you to force the
        // setter to be used (and thus validation to be done) when you have
        // a field of the same name as the database column
        map.put(columnName, column);
    }

    private void addColumn(final String name, final MutableColumn column) {
        addColumnImpl(normalColumns, name, column);
    }

    private void addKeyColumn(final String name, final MutableColumn column) {
        addColumnImpl(keyColumns, name, column);
        addColumnImpl(normalColumns, name, column);
    }

    private void scanFields(
            final Class<?> clazz,
            final boolean keyType)
            throws SecurityException {
        
        final Field[] fields = clazz.getDeclaredFields();

        for(final Field f : fields) {
            if(!Modifier.isStatic(f.getModifiers()) &&
                    !Modifier.isTransient(f.getModifiers()) &&
                    (Modifier.isPublic(f.getModifiers()) || HAVE_ACCESSIBLE_PERMISSION)) {

                String name = f.getName();
                if(f.isAnnotationPresent(ResultColumn.class)) {
                    final ResultColumn col = f.getAnnotation(ResultColumn.class);
                    name = col.value();
                }

                if(keyType || f.isAnnotationPresent(AutoGeneratedKeys.class)) {
                    addKeyColumn(name, new MutableField(
                            name,
                            f,
                            HAVE_ACCESSIBLE_PERMISSION));
                } else {
                    addColumn(name, new MutableField(
                            name,
                            f,
                            HAVE_ACCESSIBLE_PERMISSION));
                }
            }
        }
    }

    private void scanMethods(
            final Class<?> clazz,
            final boolean keyType)
            throws SecurityException {

        final Method[] methods = clazz.getDeclaredMethods();

        for(final Method m : methods) {
            if(!Modifier.isStatic(m.getModifiers()) &&
                    (Modifier.isPublic(m.getModifiers()) || HAVE_ACCESSIBLE_PERMISSION) &&
                    m.isAnnotationPresent(ResultColumn.class) &&
                    m.getParameterTypes().length == 1) {

                final ResultColumn col = m.getAnnotation(ResultColumn.class);

                if(keyType || m.isAnnotationPresent(AutoGeneratedKeys.class)) {
                    addKeyColumn(col.value(), new MutableProperty(
                            col.value(),
                            m,
                            null,
                            m.getParameterTypes()[0],
                            HAVE_ACCESSIBLE_PERMISSION));
                } else {
                    addColumn(col.value(), new MutableProperty(
                            col.value(),
                            m,
                            null,
                            m.getParameterTypes()[0],
                            HAVE_ACCESSIBLE_PERMISSION));
                }
            }
        }
    }

    private static boolean checkAccessablePermission() {
        // we perform the same check as AccessableObject will perform
        final SecurityManager manager = System.getSecurityManager();

        if(manager != null) {
            try {
                manager.checkPermission(new ReflectPermission(
                        "suppressAccessChecks"));
            } catch(final SecurityException exception) {
                return false;
            }
        }

        return true;
    }

    private static void purgeOldReferences() {
        CachedBinding binding;

        while((binding = (CachedBinding)referenceQueue.poll()) != null) {
            cache.replace(binding.dataObjectClass, binding);
        }
    }

    private static DataObjectBindingCache putCachedBinding(
            final CachedBinding bindingRef,
            final DataObjectBindingCache binding) {

        final CachedBinding existing = cache.putIfAbsent(
                bindingRef.dataObjectClass, bindingRef);

        if(existing != null) {
            final DataObjectBindingCache existingBinding = existing.get();

            if(existingBinding == null) {
                // the get method will have removed the object from the cache
                // we cycle round and try again
                return putCachedBinding(bindingRef, binding);
            }
        }

        return binding;
    }

    private static DataObjectBindingCache createDataObjectBinding(final Class<?> clazz) {
        final DataObjectBindingCache cachedBinding = new DataObjectBindingCache(
                clazz);
        final CachedBinding binding = new CachedBinding(cachedBinding,
                referenceQueue, clazz);

        return putCachedBinding(binding, cachedBinding);
    }

    Map<ColumnName, MutableColumn> getNormalColumns() {
        return normalColumns;
    }

    Map<ColumnName, MutableColumn> getKeyColumns() {
        return keyColumns;
    }

    static DataObjectBindingCache getDataObjectBindingCache(final Class<?> clazz) {
        purgeOldReferences();
        final CachedBinding bindingReference = cache.get(clazz);

        if(bindingReference == null) {
            return createDataObjectBinding(clazz);
        } else {
            final DataObjectBindingCache bindingCache = bindingReference.get();

            if(bindingCache == null) {
                return createDataObjectBinding(clazz);
            } else {
                return bindingCache;
            }
        }
    }

    /**
     * Because many databases return column names in different case to how you specify them,
     * this little class is a case-independant String.
     */
    static class ColumnName {

        private final String column;

        private final String ucase;

        public ColumnName(final String name) {
            column = name;
            ucase = column.toUpperCase();
        }

        public String getColumnName() {
            return column;
        }

        @Override
        public int hashCode() {
            return ucase.hashCode();
        }

        @Override
        public boolean equals(final Object obj) {
            if(obj instanceof ColumnName) {
                return ucase.equals(((ColumnName)obj).ucase);
            }

            return false;
        }

        @Override
        public String toString() {
            return getColumnName();
        }

    }

    private static class CachedBinding extends SoftReference<DataObjectBindingCache> {

        private final Class<?> dataObjectClass;

        public CachedBinding(
                final DataObjectBindingCache referent,
                final ReferenceQueue<? super DataObjectBindingCache> q,
                final Class<?> dataObjectClass) {

            super(referent, q);
            this.dataObjectClass = dataObjectClass;
        }

        @Override
        public DataObjectBindingCache get() {
            final DataObjectBindingCache object = super.get();

            if(object == null) {
                cache.remove(dataObjectClass);
            }

            return object;
        }

    }
}
